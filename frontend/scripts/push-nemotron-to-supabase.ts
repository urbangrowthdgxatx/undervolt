/**
 * Push Nemotron-generated answers from eval/results/nemotron-vs-current.json
 * into the cached_answers table with model versioning metadata.
 *
 * Prerequisites:
 *   1. Run the SQL migration: scripts/migrations/001-add-model-versioning.sql
 *   2. Have nemotron-vs-current.json generated (133 answers)
 *
 * Usage:
 *   npx tsx scripts/push-nemotron-to-supabase.ts
 */
import { createClient } from "@supabase/supabase-js";
import crypto from "crypto";
import fs from "fs";
import path from "path";

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
const supabase = createClient(supabaseUrl, supabaseKey);

const MODEL = "nvidia/llama-3.1-nemotron-nano-8b-v1";

function hashQuestion(q: string): string {
  return crypto.createHash("md5").update(q.toLowerCase().trim()).digest("hex");
}

// Extract a key statistic from answer text
function extractKeyStat(text: string): string | null {
  const boldMatch = text.match(/\*\*([^*]+)\*\*/);
  if (boldMatch) return boldMatch[1].slice(0, 40);

  const pctMatch = text.match(/(\+?\d[\d,]*\.?\d*%)/);
  if (pctMatch) return pctMatch[1];

  const ratioMatch = text.match(/(\d+:\d+)/);
  if (ratioMatch) return ratioMatch[1];

  const multMatch = text.match(/(\d+x\s+(?:more|less|higher|lower|greater))/i);
  if (multMatch) return multMatch[1];

  const numMatch = text.match(/([\d,]+(?:\.\d+)?)\s+(installations?|permits?|systems?|chargers?|generators?|units?|homes?|projects?|buildings?)/i);
  if (numMatch) return `${numMatch[1]} ${numMatch[2]}`;

  return null;
}

async function main() {
  const resultsPath = path.join(__dirname, "..", "eval", "results", "nemotron-vs-current.json");

  if (!fs.existsSync(resultsPath)) {
    console.error("Results file not found:", resultsPath);
    console.error("Run generate-nemotron-answers.py first.");
    process.exit(1);
  }

  const results = JSON.parse(fs.readFileSync(resultsPath, "utf-8"));
  console.log(`Loaded ${results.length} Nemotron answers\n`);

  let success = 0;
  let errors = 0;

  for (const row of results) {
    const question = row.question;
    const answer = row.nemotron_answer;
    const hash = hashQuestion(question);

    if (answer.startsWith("ERROR")) {
      console.log(`SKIP (error): ${question.slice(0, 60)}`);
      errors++;
      continue;
    }

    // Build headline from first sentence
    const cleanedResponse = answer
      .replace(/^(here is |here are |here's |this is |the following |based on |according to )/i, "")
      .replace(/^\*\*/g, "")
      .trim();
    const firstSentence = cleanedResponse.split(/[.!?\n]/)[0].replace(/\*\*/g, "").trim();
    const headline =
      firstSentence.length > 50 ? firstSentence.substring(0, 47) + "..." : firstSentence || "Austin Insight";

    const keyStat = extractKeyStat(answer);

    const responseObject = {
      message: answer,
      storyBlock: {
        id: `nemotron-${hash.slice(0, 8)}-${Date.now()}`,
        question,
        headline,
        insight: answer,
        dataPoint: keyStat ? { label: "Key finding", value: keyStat.slice(0, 30) } : null,
        whyStoryWorthy: "turning-point",
        evidence: [
          { stat: "Analyzed from 2.34M Austin permits (2000-2026)", source: "Austin Open Data via Supabase" },
          { stat: `Generated by ${MODEL}`, source: "NVIDIA NIM API" },
        ],
        confidence: "high",
      },
    };

    const { error } = await supabase.from("cached_answers").upsert(
      {
        question,
        question_hash: hash,
        answer: responseObject,
        storyline: row.storyline || null,
        model: MODEL,
        model_metadata: {
          generated_at: row.generated_at,
          temperature: 0.6,
          max_tokens: 512,
          source: "nim-api-batch",
          category: row.category,
          eval_file: "nemotron-vs-current.json",
        },
        updated_at: new Date().toISOString(),
      },
      { onConflict: "question_hash,model" }
    );

    if (error) {
      console.error(`FAIL: ${question.slice(0, 60)} â€” ${error.message}`);
      errors++;
    } else {
      const dp = keyStat || "(no stat)";
      console.log(`OK [${dp}]: ${question.slice(0, 60)}`);
      success++;
    }
  }

  console.log(`\nDone! Success: ${success} | Errors: ${errors}`);
}

main().catch(console.error);
